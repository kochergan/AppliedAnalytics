
# Практична частина. Робота з даними {#processing}

## Про дані в цій книзі {#aboutdata}

У цій книзі ми будемо використовувати дані моніторингу забруднення атмосферного повітря в місті Кривий Ріг Дніпропетровської області (Україна). 
У Кривому Розі працює декілька незалежних мереж моніторингу. Ми будемо використовувати дані з двох мереж: мережа спостережних постів Гідрометеоцентру України та мережа автоматизованих спостережних постів ПАТ «АрселорМіттал Кривий Ріг». Від Гідрометеоцентру України в Кривому Розі працює 5 постів. Мережа «АрселорМіттал Кривий Ріг» представлена трьома автоматизованими постами. Розташування постів на місцевості показано на схемі. Фоновим рисунком для схеми є знімок космічного апарату **Sentinel-2A** від 5 квітня 2016 року. На знімку добре видно як дим від криворізьких заводів поширюється над житловими районами Кривого Рогу.

```{r fig.align='center', fig.cap = "Схема розташування постів моніторингу забруднення повітря в Кривому Розі", echo=FALSE, include=identical(knitr:::pandoc_to(), 'html')}
knitr::include_graphics('images/Book_shema_post.jpg', dpi = 75)
```

Спостережні пости Гідрометеоцентру являють собою напівавтоматизовані агрегати. Вимірювання концентрацій забруднюючих речовин здійснюється 2-4 рази на добу. Відібране повітря аналізується в лабораторії. Первинні дані раз на місяць передаються до центрального обчислювального центру (м.Київ) у закодованому вигляді. Файл з даними, які ми будемо використовувати, називається **air_pollution.csv** і містить результати спостережень упродовж січня 2015 --- серпня 2016 року.

```{r fig.align='center', fig.cap = "Загальний вигляд спостережного посту Гідрометеоцентру", echo=FALSE, include=identical(knitr:::pandoc_to(), 'html')}
knitr::include_graphics('images/Gidromet_post.jpg', dpi = 75)
```

Кожна проба повітря відбирається протягом 20 хвилин. Тобто проба, відібрана о 7:00 буде характеризувати концентрації забрудників о 6:40-7:00. В подальшому ми будемо оперувати тільки часом закінчення відбору проби, передбачаючи що протягом 20 хвилин суттєвих змін у складі повітря не відбувалось. Таке спрощення дозволить нам поєднувати дані моніторингу з метеорологічними даними «напряму», уникаючи при цьому перетворення первинних даних.

Таблиця із даними Гідрометеоцентру містить наступні поля:

* **date.proba** --- дата відбору проби повітря

* **time.proba** --- час відбору проби повітря

* **name** --- назва спостережного посту

* **TSP** --- концентрація пилу (суспендовані тверді частки), мг/м³ (вимірюється на постах «ПСЗ-2», «ПСЗ-6», «ПСЗ-7»)

* **SO2** --- концентрація діоксиду сірки, мг/м³

* **CO** --- концентрація монооксиду вуглецю, мг/м³

* **NO2** --- концентрація діоксиду азоту, мг/м³

* **NO** --- концентрація монооксиду азоту (вимірюється тільки на пості «ПСЗ-3»), мг/м³

* **H2S** --- концентрація сірководню, мг/м³

* **C6H6O** --- концентрація фенолу, мг/м³

* **NH3** --- концентрація аміаку, мг/м³

* **CH2O** --- концентрація формальдегіду, мг/м³

Для завантаження файлу з даними Гідрометеоцентру в робоче середовище мови **R** слід використати команду:

```{r eval = FALSE}
#Завантажуємо файл air_poolution.csv:
air_pollution <- read.csv("air_poolution.csv", header = TRUE, sep = ";", dec = ",")
```

Таблиця з даними Гідрометеоцентру містить `r ncol(air_pollution)` полів та `r nrow(air_pollution)` записів.

```{r eval = TRUE}
#Виводимо на екран вміст таблиці air_pollution.
#Примусово викликаємо функцію tbl_df із пакету dplyr
dplyr::tbl_df(air_pollution)
```

Як бачимо з виводу таблиці на екран --- поля *date.proba*, *time.proba* та *name* належать до класу «фактор» (*\<fctr\>* --- factor). Поле *CO* належить до класу цілих чисел (*\<int\>* --- integer). Воно так розпізналось через те, що концентрації монооксиду вуглецю вказани тільки цілими числами. Всі інші поля належать до класу числових (*\<dbl\>* --- double).

Дані автоматизованого моніторингу забруднення повітря представлено даними, отриманими на трьох спостережних постах ПАТ «АрселорМіттал Кривий Ріг». Ці дані містяться в трьох окремих файлах. Це файли під назвами **Ordzh52.csv**, **Landau2a.csv** та **Podlepy41.csv**. У цих файлах міститься інформація про концентрації забруднюючих речовин упродовж 1 січня 2015 року --- 22 вересня 2015 року.

```{r fig.align='center', fig.cap = "Загальний вигляд автоматизованого спостережного посту", echo=FALSE, include=identical(knitr:::pandoc_to(), 'html')}
knitr::include_graphics('images/Arcelor_post.jpg', dpi = 75)
```

За нормального режиму роботи вимірювання виконуються кожні 20 хвилин. Проте, іноді трапляються збої в роботі обладнання або в мережі передачі даних. Через це дані автоматизованого моніторингу містять пропущені значення. Складності до структури даних додає методика запису в базу даних. Справа у тому, що кожен із трьох автоматизованих постів складається з двох окремих систем. Це система вимірювання концентрацій газоподібних речовин та система вимірювання метеорологічних параметрів та концентрацій пилу. При цьому вимірювання метеорологічних параметрів здійснюється кожні 10 хвилин. Кожна з цих двох систем надсилає дані окремо. Як результат --- вимірювання, які виконано в однакові проміжки часу записуються до бази даних окремими рядками. Але існує ще одна проблема! Справа у тому, що через збої обладнання зміщуються часові інтервали вимірювань. Як наслідок --- вимірювання «кожні 20 хвилин» будуть не обов’язково у 00-20-40 хвилин кожної години. Вони можуть виконуватись, наприклад, у 13-33-53 хвилини або у 07-27-47 хвилин. Це призводить до того, що у нас зміщуються всі вимірювання і в такому великому масиві даних ми втрачаємо можливість адекватного поєднання та порівняння даних. Щоб уникнути цієї проблеми можна фактичні інтервали вимірювань «округляти» до найближчого інтервалу 00, 20 або 40 хвилин. При цьому ми приймаємо тезу, що в ці хвилини, на які ми зміщуємо фактичний час вимірювання, у довкіллі суттєвих змін не відбувалось.

Таблиці з даними ПАТ «АрселорМіттал Кривий Ріг» містять наступні поля:

* **name** --- назва спостережного посту

* **date.time** --- дата та час вимірювання

* **NO2** --- концентрація діоксиду азоту, мг/м³

* **NO** --- концентрація монооксиду азоту, мг/м³

* **SO2** --- концентрація діоксиду сірки, мг/м³

* **CO** --- концентрація монооксиду вуглецю, мг/м³

* **NH3** --- концентрація аміаку, мг/м³ (вимірюється лише на посту «Ландау-2»)

* **H2S** --- концентрація сірководню, мг/м³ (вимірюється лише на посту «Ландау-2»)

* **ws.post** --- швидкість вітру в місці розташування посту, м/с

* **wd.post** --- напрям вітру в місці розташування посту (звідки дме), градуси

* **temp.post** --- температура в місці розташування посту, °C

* **rh.post** --- відносна вологість повітря в місці розташування посту, %

* **press.post** --- атмосферний тиск у місці розташування посту, мм.рт.ст.

* **TSP** --- концентрація пилу (суспендовані тверді частки), мг/м³

Для того, щоб завантажити файли з даними ПАТ «АрселорМіттал Кривий Ріг», слід виконати команди:

```{r eval = FALSE}
#Завантажуємо файл Ordzh52.csv:
Ordzh52 <- read.csv("Ordzh52.csv", header = TRUE, sep = ";", dec = ",")
#Завантажуємо файл Landau2a.csv
Landau2a <- read.csv("Landau2a.csv", header = TRUE, sep = ";", dec = ",")
#Завантажуємо файл 
Podlepy41 <- read.csv("Podlepy41.csv", header = TRUE, sep = ";", dec = ",")
```

Розміри таблиць з даними автоматизованого моніторингу наступні:

* **Ordzh52** - `r ncol(Ordzh52)` полів та `r nrow(Ordzh52)` записів

* **Landau2a** - `r ncol(Landau2a)` полів та `r nrow(Landau2a)` записів

* **Podlepy41** - `r ncol(Podlepy41)` полів та `r nrow(Podlepy41)` записів

Структура всіх трьох таблиць однакова. Єдине, що треба зауважити --- для таблиць **Ordzh52** та **Podlepy41** в полях «аміак» (*NH3*) та «сірководень» (*H2S*) будуть лише порожні значення (*NA*), оскільки на цих двох постах ці речовини не вимірюються.

```{r eval = TRUE}
#Виводимо на екран вміст таблиці Landau2a.
#Примусово викликаємо функцію tbl_df із пакету dplyr
dplyr::tbl_df(Landau2a)
```

В таблицях **Ordzh52**, **Landau2a** та **Podlepy41** поля *name* та *date.time* належать до класу «фактор» (*\<fctr\>* --- factor). Всі інші поля є числовими і належать до класів цілих чисел (*\<int\>* --- integer) та десяткових дробів (*\<dbl\>* --- double). Зверніть увагу на те, що в записах таблиці дублюється час вимірювань: два записи за *01/01/2015 00:00:00*, два записи за *01/01/2015 00:40:00*. Це пов’язано із тим, що кожен із автоматизованих постів має дві подсистеми вимірювань: окремо вимірюються концентрації газоподібних забруднюючих речовин, окремо --- меторологічні параметри та концентрації пилу. Тим більше --- в той час як концентрації газоподібних забруднюючих речовин та пилу вимірюються кожні 20 хвилин, метеорологічні параметри вимірюються кожні 10 хвилин. Як привести такі вимірювання до єдиної позначки часу ми розглянемо в розділі \@ref(brashjoin).

## Звіримо годинники! {#sessioninfo}
```{r include = FALSE, }
library(extrafont)
```

Все програмне забезпечення, яке розглядається у цій книзі, є вільним кросплатформним програмним забезпеченням. Усі ці програми будуть працювати й в середовищі операційної системи **Linux**, й в середовищі **Windows**, й у **FreeBSD** і в інших системах... Проте, правилами гарного тону вважається наведення відомостей --- в якій конкретно системі працює автор та яку версію програмного забезпечення він використовує. Щоб подивитись параметри власного комп’ютера та версію мови програмування **R** слід використати функцію *sessionInfo*.

```{r session_info, echo=TRUE, message=TRUE, warning=TRUE, out.width='80%'}
sessionInfo()
```

Як зрозуміло з відповіді функції *sessionInfo* --- автор працює на комп’ютері зі встановленою операційною системою **Debian GNU/Linux 8 (jessie)** та використовує мову програмування **R** версії **3.3.2** від **31 жовтня 2016 року**.

Стосовно інтегрованого середовища розробки **RStudio** --- використовую **RStudio** версії **1.0.44**.

Іще перевіремо --- які гарнітури у мене встановлено в системній директорії мови **R**. Для цього використаємо команду *fonts* пакету **extrafont**

```{r eval = TRUE}
fonts()
```

У мене для роботи **R** встановлено 43 гарнітури, які можна використовувати при створенні графічних матеріалів беспосередньо засобами мови **R**.

## Підготовка даних моніторингу {#preparation}

## Отримання метеорологічних даних {#getmeteo}

```{r include = FALSE, }
load(file = ".RData")
library(stationaRy)
library(dplyr)
```

У розділах \@ref(stationary) та \@ref(meteodata) було коротко розглянуто пакет **stationaRy** та можливості отримання даних метеорологічних спостережень. Зараз ми, нарешті, приступаємо до практичної частини --- отримання метеорологічних даних з бази даних Агенції атмосферних та океанічних досліджень США [NOAA](http://www.noaa.gov/). Сподіваюсь --- ви не забули встановити та запустити пакет **stationaRy**?

Також нам знадобиться пакет **dplyr**. Ми будемо використовувати функцію *filter* із цього пакету і так званий «тунельний інтерфейс» (pipeline). Що це за інтерфейс ми розглядали в розділі \@ref(dplyr).

```{r eval = FALSE}
library(stationaRy)
library(dplyr)
```

У таблиці \@ref(ukrstations.table) розділу \@ref(meteodata) ми перелічили всі доступні в базі даних NOAA українські метеостанції. Свій вибір ми зупинили на метеостанції (точніше --- на масиві даних) під назвою **«LOZUVATKA INTL»**. Це метеорологічні спостереження для цивільної авіації. Якщо вам треба ознайомитись з усіма доступними в базі NOAA масивами даних, ви можете використати наступну команду, яка отримає з сервера перелік всіх доступних масивів даних та збереже його у вигляді таблиці *met_stations* безпосередньо в R:

```{r eval = FALSE}
met_stations <- get_isd_stations()
```

Ми можемо зберігти таблицю *met_stations* в окремий файл, наприклад формату CSV:

```{r eval = FALSE}
write.csv(met_stations, "met_stations.csv", row.names = FALSE)
```

Якщо ви хочете одразу вибрати лише українські метеостанції, то вам треба відфільтрувати загальний перелік за полем *country_name*:

```{r eval = FALSE}
get_isd_stations() %>%
    filter(country_name == "Ukraine") -> ukr.met_stations
```

У випадку коли ви не знаєте як може називатись найближча до вас метеостанція --- можна відфільтрувати метеостанції в межах конкретних географічних координат. Для цього слід задати фільтрування в географічних координатах

```{r eval = FALSE}
get_isd_stations() %>%
    filter(lat > 48.0, lat < 49.0,
           lon > 31.5, lon < 35.5) -> coord.met_stations
```

```{r echo = FALSE}
coord.met_stations
```
У заданих координатах знаходяться 11 метеорологічних станцій, дані з яких доступні в базі даних NOAA. Із цих станцій працюють всі окрім метеостанції в місті Підгородне Дніпропетровської області (*P0DGORODNOYE*). Для цієї метеостанції доступні дані лише за 1957-1963 рр.

Тепер можна приступати безпосередньо до отримання даних. В цьому процесі є невеличка незручність. Справа у тому, що дані формату METAR передаються із позначкою часу [UTC](https://en.wikipedia.org/wiki/Coordinated_Universal_Time) (всесвітній координований час). Але різниця часу між UTC та місцевим часом в Україні становить 2 години взимку і 3 години влітку. І коли ми будемо вибирати дані, наприклад, за 2016 рік, то фактично ми отримаємо таблицю в якій будуть відсутні 4 спостереження за 1 січня, натомість будуть зайві (для місцевого часу) спостереження 31 грудня. Щоб уникнути цього --- доведеться вказати діапазон із запасом «на рік назад» і завантажувати дані за два роки: 2015 та 2016.

Отримання метеорологічних даних з бази даних NOAA і збереження в окрему таблицю здійснюється за допомогою набору команд:

```{r eval = FALSE}
#отримуємо повний перелік метеостанцій:
get_isd_stations() %>%
  #вибираємо метеостанцію «LOZUVATKA INTL»:
  select_isd_station(name = "LOZUVATKA INTL") %>%
  #записуємо отримані дані в таблицю KrR_meteo:
  get_isd_station_data(startyear = 2015, endyear = 2016) -> KrR_meteo
```

Ми отримали таблицю *KrR_meteo*, в якій містяться всі повідомлення формату METAR від метеостанції «Кривий Ріг» за 2015 та 2016 роки. Ну, точніше, не зовсім всі: за місцевим часом відсутні повідомлення за перші 2 години 2015 року проте присутні зайві повідомлення за перші дві години 2017 року... Таблиця містить `r ncol(KrR_meteo)` полів та `r nrow(KrR_meteo)` записів!

Давайте розглянемо --- які метеорологічні дані ми отримали:

```{r eval = TRUE}
#виводимо на екран вміст таблиці KrR_meteo:
KrR_meteo
```

Оскільки у нас завантажений пакет **dplyr**, то таблиця *KrR_meteo* розпізнається як об’єкт *tibble*. При цьому показуються перші 10 рядків і по ширині --- «скільки влазить на екран». Без завантаженого **dplyr** вона буде відображатись як звичайний *data.frame*. Таблиця складається переважно з числових полів (*\<dbl\>* --- double). Лише два перші поля --- символьні (*\<chr\>* --- character) і останнє поле дата-час у форматі *POSIXct* (*\<dttm\>* --- date-time).

Бажано перевірити отриману таблицю на наповненість даними, щоб мати загальну уяву про показники в таблиці. Найпростіший варіант --- використати функцію *summary*:

```{r eval = TRUE}
summary(KrR_meteo)
```

Тепер розглянемо що власне означають поля таблиці. Перші два поля *usaf* та *wban* --- це індексація масиву даних «LOZUVATKA INTL» в загальній базі даних NOAA. Ці два поля нас зовсім не цікавлять. Стосовно дати та часу --- не забувайте, що в повідомленнях METAR позначка часу ставиться у форматі UTC! Із усіх полів таблиці для нас важливі поля метеорологічних параметрів та останнє поле дати-часу. Метеорологічні параметри в таблиці наступні:

* **wd** --- напрям вітру, градуси (**звідки дме!**)

* **ws** --- швидкість вітру, м/с

* **ceil_hgt** --- висота нижньої границі хмарності, м

* **temp** --- температура повітря, °C

* **dew_point** --- точка роси, °C

* **atmos_pres** --- атмосферний тиск приведений до рівня моря, гПа

* **rh** --- відносна вологість повітря, %

В отриманій таблиці не вистачає дуже важливого параметру --- атмосферного тиску. Поле «атмосферний тиск» в таблиці є (*atmos_pres*), але воно порожнє. Справа в тому, що окрім основного масиву даних існують також додаткові. В цих додаткових масивах міститься ще дуже багато інформації, зокрема --- типи метеорологічних ситуацій під час спостережень. Ознайомитись зі структурою даних, які зберігаються на ресурсах NOAA можна за документом Національного центру кліматичних даних США [@meteoman]. Більш стистено інформація про додаткові масиви даних міститься на [сторінці GitHub](https://github.com/rich-iannone/stationaRy) автора пакету **stationaRy**. Загалом у переліку фігурують 86 масивів даних, із яких можна завантажити 489 додаткових параметрів, включаючи параметри якості самих даних.

Дані про атмосферний тиск містяться в додатковому масиві даних **MA1**. Щоб отримати таблицю зі значеннями атмосферного тиску --- треба «замовити доставку» даних із цього додаткового масиву:

```{r eval = FALSE}
#отримуємо повний перелік метеостанцій:
get_isd_stations() %>%
  #вибираємо метеостанцію «LOZUVATKA INTL»:
  select_isd_station(name = "LOZUVATKA INTL") %>%
  #вибираємо часовий проміжок метеорологічних даних:
  get_isd_station_data(startyear = 2015, endyear = 2016,
  #вказуємо додатковий масив, який треба приєднати:
  select_additional_data = c("MA1")) -> KrR_meteo2
```

Тепер у нас є таблиця *KrR_meteo2*. У порівнянні з попередньою таблицею, в цій додалось ще чотири поля: *ma1_1*, *ma1_2*, *ma1_3* та *ma1_4*. Значення атмосферного тиску містяться у полі *ma1_1*.

Ми просто перепишем дані атмосферного тиску в поле *atmos_pres* і викинемо з таблиці непотрібні поля:

```{r eval = FALSE}
#заганяємо таблицю KrR_meteo2 в тунель
KrR_meteo2 %>%
  #переписуємо дані з поля ma1_1 в поле atmos_pres
  mutate(atmos_pres = ma1_1) %>%
  #викидаємо непотрібні поля та записуємо результат
  select(-c(usaf, wban, ceil_hgt,  ma1_1,
            ma1_2, ma1_3, ma1_4)) -> KrR_meteo2
```
Але наші маніпуляції з метеорологічними даними ще не закінчились! Нам треба перевести час із часового поясу UTC у час за Києвом. А ще треба напрямок вітру із градусів перевести в румби.

Перевести час доволі просто:

```{r eval = FALSE}
#примусово задаємо даним часовий пояс UTC в новому полі
KrR_meteo2$time.UTC <- as.POSIXct(format(KrR_meteo2$time),  tz="UTC")
#створюємо нове поле та переводимо час
KrR_meteo2$time.Kiev <- as.POSIXct(format(KrR_meteo2$time.UTC,
      tz="Europe/Kiev", usetz=TRUE))
```

Із напрямками вітру ситуація дещо складніша. Справа у тому, що окрім стійкого вітру певного напрямку можливі ще два типи «вітру» --- слабкий вітер змінного напрямку та повний штиль. Щоб врахувати ці два типи нам необхідно оперувати не тільки показником «напрямок вітру», а й показником «швидкість вітру». Поєднання двох цих полів дає нам три варіанти метеорологічних умов:

1. **стійкий вітер певного напрямку** --- швидкість вітру більше нуля і непорожнє значення напрямку вітру

2. **вітер змінного напрямку** --- швидкість вітру більше нуля і порожнє значення напрямку вітру

3. **повний штиль** --- швидкість вітру дорівнює нулю і порожнє значення напрямку вітру

Для напрямків вітру ми використаємо 16-рубмову схему. В результаті виконання нижченаведеного скрипту ми отримаємо в таблиці *KrR_meteo2* поле *DD.meteo.from*. У цьому полі будуть міститись ранжовані за зростанням 16 румбів (за годинниковою стрілкою) та два додаткових параметри: вітер змінного напрямку (*VRB*) і повний штиль (*CALM*). Навіщо ми ранжували значення? --- В подальшому при побудові графіків напрямки вітру будуть відображатись в порядку румбів, а не в алфавітному порядку.

```{r eval = FALSE}
tbl_df(KrR_meteo2) %>%
  #присвоюємо "-1" порожнім значенням напрямку вітру:
  mutate(wd = ifelse(is.na(wd), -1, wd)) %>%
  #створюємо та обчислюємо поле DD.meteo.from
  mutate(DD.meteo.from = ordered(
  ifelse((wd >= 168.75 & wd < 191.25 & ws > 0),"S",
  ifelse((wd >= 191.25 & wd < 213.75 & ws > 0),"SSW",
  ifelse((wd >= 213.75 & wd < 236.25 & ws > 0),"SW",
  ifelse((wd >= 236.25 & wd < 258.75 & ws > 0),"WSW",
  ifelse((wd >= 258.75 & wd < 281.25 & ws > 0),"W",
  ifelse((wd >= 281.25 & wd < 303.75 & ws > 0),"WNW",
  ifelse((wd >= 303.75 & wd < 326.25 & ws > 0),"NW",
  ifelse((wd >= 326.25 & wd < 348.75 & ws > 0),"NNW",
  ifelse((wd >= 348.75 & wd <= 360 & ws > 0),"N",
  ifelse((wd >= 0 & wd < 11.25 & ws > 0),"N",
  ifelse((wd >= 11.25 & wd < 33.75 & ws > 0),"NNE",
  ifelse((wd >= 33.75 & wd < 56.25 & ws > 0),"NE",
  ifelse((wd >= 56.25 & wd < 78.75 & ws > 0),"ENE",
  ifelse((wd >= 78.75 & wd < 101.25 & ws > 0),"E",
  ifelse((wd >= 101.25 & wd < 123.75 & ws > 0),"ESE",
  ifelse((wd >= 123.75 & wd < 146.25 & ws > 0),"SE",
  ifelse((wd >= 146.25 & wd < 168.75 & ws > 0),"SSE",
  ifelse((wd < 0 & ws > 0), "VRB", "CALM"
  )))))))))))))))))), levels = c("N","NNE","NE",
  "ENE","E","ESE","SE","SSE","S","SSW", "SW","WSW",
  "W","WNW","NW","NNW", "VRB", "CALM"))) %>%
  #повертаємо на місце порожні значення
  mutate(wd = ifelse(wd == -1, NA, wd)) -> KrR_meteo2
```

В принципі --- все! Тепер у нас є готова для використання таблиця метеорологічних спостережень. В наступних розділах ми приєднаємо дані з цієї таблиці до даних моніторингу якості атмосферного повітря. Це надасть нам можливість аналізувати зв’язок погодних умов із показниками забруднення атмосферного повітря. Єдине, що слід додати --- це те, що отримані метеорологічні дані не завадить перевірити. У мене було декілька випадків, коли через проблеми з інтернет-з’єднанням дані надходили не в повному обсязі: були пробіли від декількох днів до декількох тижнів. Одним із способів перевірки такого великого обсягу даних є побудова так званих «календарних діаграм», коли в якості відображуваного параметру використовується кількість записів для кожного дня. За умов стабільної роботи метеостанція «Кривий Ріг» повинна передавати не менше 48 METAR-повідомлень щодоби. Якщо в отриманій вами таблиці деякі дні містять лише 2-3 записи, а деякі дні --- взагалі відсутні, скоріше за все це проблема передачі-отримання даних. Створення «календарних діаграм» ми розглянемо в розділі \@ref(calendarplots).

## Об’єднання метеорологічних та екологічних даних {#datajoin}

В розділі \@ref(getmeteo) ми отримали дані метеорологічних спостережень на метеостанції «Кривий Ріг». Тепер нам треба об’єднати 

### Спостереження співпадають за часом {#simplejoin}

### Спостереження не співпадають за часом {#interjoin}

У випадку, коли спостереження не співпадають за часом, я пропоную використовувати інтерполяцію значень. Як це працює? - Ми просто «розтягуємо» значення одного із масивів: або даних моніторингу повітря, або даних метеорологічних спостережень. Приймаючи до уваги те, що у нашому випадку базовим об’єктом досліджень є дані моніторингу повітря, доцільніше робити інтерполяцію даних метеоспостережень. Ми обчислемо проміжні значення щоб у нас були «вимірювання» метеопараметрів не кожні 30, а кожні 10 хвилин. І допоможе нам це зробити пакет **zoo**, який ми з вами розглядали в розділі \@ref(workpackages).

Пакет **zoo** працює з об’єктами власного формату. Формат (клас) цих об’єктів так і називається: *zoo*. Після інтерполяції нам треба буде переформатувати результат у таблицю даних (*data frame*). Перед початком роботи слід завантажити пакет **zoo**.

```{r eval = FALSE}
library(zoo)
```

Для інтерполяції даних метеорологічних спостережень ми використаємо таблицю *KrR_meteo2*, яку отримали в розділі \@ref(getmeteo). Тільки нам доведеться викинути з цієї таблиці всі зайві поля, інтерполяція яких не матимиме сенсу: рік, година, хвилина, широта-довгота, висотна позначка, два непотрібні нам поля дата-час та поле румбів. Румби ми потом визначимо наново, використавши для цього вже інтерпольовані значення з поля «напрям вітру» (*wd*).

Наша інтерполяція базується на апріорній тезі, що метеорологічні умови змінюються між двома граничними точками інтерполяції поступово і з однаковою швидкістю. Тобто --- від 00 хвилин до 30 хвилин кожної години якщо ми будемо інтерполювати значення на відрізки по 10 хвилин --- то змінення значень всередині цих трьох відрізків буде однаковим. Тобто ми застосовуємо просту лінійну інтерполяцію. Що стосується поля «напрям вітру», яке представлено в градусах, ми також приймаємо тезу, що змінення напрямку вітру відбувається на рівнозначні величини всередині граничних точок. Але в полі «напрям вітру» є ще порожні значення. Якщо граничні точки інтерполяції містять порожні значення, то порожніми будуть всі значення між ними і також всі значення до наступного непорожнього значення.

Із напрямком вітру це ще не всі проблеми з якими ми зустрілись. Справа у тому, що напрям вітру --- циклічна величина. Вона вимірюється у градусах і в неї немає початку відліку. Нуль одночасно є і закінченням. Щоб інтерполювати значення між двома точками ми не можемо напряму використати лінійну інтерполяцію. Ми не зможемо проінтерполювати значення між 340° та 10° --- у нас вийдуть значення в діапазоні від 10 до 340... Для вирішення цієї проблеми я зробив перетворення за допомогою тригонометричних функцій і в самому кінці «зібрав» синуси та косинуси в єдине значення. І замість порожніх значень нам потрібні великі від’ємні числа. Це робиться для того, щоб потім в процесі інтерполяції відрізнити первинні порожні значення від порожніх значень у новостворених часових інтервалах. В самому кінці розрахунку всім великим від’ємним числам ми повернемо значення *NA*.

```{r eval = FALSE}
#створюємо робочу таблицю первинних значень для інтерполяції:
met.approx <- KrR_meteo2[, c(9:14, 17)]
#обчислюємо сінуси та косінуси напрямків вітру:
met.approx$wd.sin <- sin(pi * met.approx$wd/180)
met.approx$wd.cos <- cos(pi * met.approx$wd/180)
#присвоюємо значення -1000000 порожнім записам:
met.approx$wd.sin[is.na(met.approx$wd.sin)] <- -1e+6
met.approx$wd.cos[is.na(met.approx$wd.cos)] <- -1e+6
#створюємо часовий вектор із кроком 600 секунд
#на основі цього вектору будемо здійснювати інтерполяцію:
seq.time <- zoo(order.by = (as.POSIXct(seq(min(met.approx$time.Kiev),
      max(met.approx$time.Kiev), by = 600))))
#об’єднуємо таблицю первинних значень із часовим вектором:
mer.meteo <- merge(zoo(x = met.approx[c(2:6, 8, 9)], order.by = unique(met.approx$time.Kiev)), seq.time)
#здійснюємо інтерполяцію значень метеорологічних параметрів:
approx.meteo <- na.approx(mer.meteo)
```

Щоб претворити об’єкт *zoo* у звичайну таблицю даних можна створити власну функцію *zooToDf*. Написання цієї функції я підгледів на [Stack Overflow](http://stackoverflow.com/questions/14064097/r-convert-between-zoo-object-and-data-frame-results-inconsistent-for-different). Ми власноруч створюємо цю функцію. При цьому її буде збережено в нашому робочому середовищі.

```{r eval = FALSE}
zooToDf <- function(z) {
    df <- base::as.data.frame(z) 
    df$Date <- stats::time(z) #create a Date column
    rownames(df) <- NULL #so row names not filled with dates
    df <- df[,c(ncol(df), 1:(ncol(df)-1))] #reorder columns so Date first
    return(df)
}
```

Нам слід застосувати функцію *zooToDf* до нашого об’єкту з результатами інтерполяції *approx.meteo*. Після перетворення його на таблицю даних ми перейменуємо перше поле таблиці на *time.Kiev* та перетворимо це поле на текстове.

```{r eval = FALSE}
#перетворюємо об’єкт approx.meteo на таблицю даних:
approx.meteo.df <- zooToDf(approx.meteo)
#перейменовуємо перше поле таблиці:
colnames(approx.meteo.df)[1] <- "time.Kiev"
#перетворюємо перше поле таблиці на текстове:
approx.meteo.df$time.Kiev <- as.character(approx.meteo.df$time.Kiev)
```

Тепер нам треба зі значень синусів-косинусів повернути нормальне значення напряму вітру. Спочатку ми об’єднаємо все в єдине поле і перерахуємо в градуси. Потім округлимо ці значення до десятків градусів. Далі нам треба додати 360 до від’ємних значень, щоб перевести їх в систему координат «0-360 градусів».

У самому кінці нам треба винайти всі значення напряму вітру, які в первинній таблиці даних були порожніми і всі значення, які є результатом інтерполяції цих порожніх значень. Ви пам’ятаєте --- на самому початку інтерполяції ми присвоїли значення -1000000 всім порожнім полям синусів та косинусів. Тепер ми використаємо всі нереальні значення синусів та косинусів, щоб присвоїти значення *NA* в полі напрямку вітру. Для цього нам просто треба знайти сінуси та косінуси, які менші за -1.

```{r eval = FALSE}
#об’єднуємо значення сінусів та косинусів в поле «напрям вітру»:
approx.meteo.df$wd <- as.vector(atan2(approx.meteo.df$wd.sin, approx.meteo.df$wd.cos) * 360/2/pi)
#округляємо поле «напрям вітру» до десятків градусів:
approx.meteo.df$wd <- round(approx.meteo.df$wd, -1)
#додаємо 360 градусів всім від’ємним значенням напряму вітру:
approx.meteo.df$wd2 <- ifelse(approx.meteo.df$wd < 0, approx.meteo.df$wd + 360, approx.meteo.df$wd)
#присвоюємо порожнє значення в поле напрям вітру тим
#записам, для яких сінуси та косінуси мають
#нереальні значення:
approx.meteo.df$wd <- ifelse(approx.meteo.df$wd.sin < -1 | approx.meteo.df$wd.cos < -1, NA, approx.meteo.df$wd2)
```

В первинній таблиці *KrR_meteo2* було `r nrow(KrR_meteo2[is.na(KrR_meteo2$wd), ])` порожніх значень напрямку вітру. Після інтерполяції ми маємо `r nrow(approx.meteo.df[is.na(approx.meteo.df$wd), ])` порожніх значень.

```{r echo = TRUE}
nrow(KrR_meteo2[is.na(KrR_meteo2$wd), ])
nrow(approx.meteo.df[is.na(approx.meteo.df$wd), ])
```
Все! Тепер у нас є часовий ряд щільних метеорологічних даних із частотою кожні 10 хвилин. Нам залишилось лише видалити всі зайві поля із кінцевої таблиці.

```{r eval = FALSE}
meteo.interpolation <- approx.meteo.df[, -c(7, 8, 10)]
```

Для того, щоб остаточно привести таблицю до первинного стану нам треба округлити значення: швидкості вітру, температури, точки роси й атмосферного тиску --- до цілих значень, відносної вологості повітря --- до десятих часток.

```{r eval = FALSE}
meteo.interpolation$ws <- round(meteo.interpolation$ws, 0)
meteo.interpolation$temp <- round(meteo.interpolation$temp, 0)
meteo.interpolation$dew_point <- round(meteo.interpolation$dew_point, 0)
meteo.interpolation$atmos_pres <- round(meteo.interpolation$atmos_pres, 0)
meteo.interpolation$rh <- round(meteo.interpolation$rh, 1)
```
Щоб пересвідчитись у тому, що ми все хробили правильно --- продивимось перші 10 рядків нашої кінцевої таблиці *meteo.interpolation*.

```{r eval = TRUE}
#виводимо на екран перші 10 рядків таблиці meteo.interpolation:
head(meteo.interpolation, 10)
```

У нашій таблиці *meteo.interpolation* міститься `r nrow(meteo.interpolation)` записів. В первинній таблиці метеорологічних даних *KrR_meteo2* було `r nrow(KrR_meteo2)` записів. Тепер у нас майже в `r round(nrow(meteo.interpolation)/nrow(KrR_meteo2), 0)` рази більше даних. Якщо у нас були вимірювання тільки два рази на годину --- в 0 та 30 хвилин, то тепер у нас є шість значень --- кожні 10 хвилин. При цьому не слід забувати, що вимірювання о 0 та 30 хвилин кожної години нікуди не поділись і вони є базовими для всіх інших часових інтервалів.

### Невитримані інтервали спостережень {#brashjoin}
